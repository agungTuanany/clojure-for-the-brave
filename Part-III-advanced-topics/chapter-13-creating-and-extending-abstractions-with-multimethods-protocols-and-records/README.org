#+TITLE: Clojure For The Brave and True Part III -- Chapter 13: Creating and Extending Abstractions with Multimethods, Protocols, and Records
#+DATE: 2025-11-28 Fri
#+AUTHOR: Agung Tuanany
#+DESCRIPTION: Clojure, book, A summary per chapter from book clojure-for-the-brave-and-true.
#+KEYWORDS: programming, clojure, clojure-for-the-brave-and-true.
#+OPTIONS: toc:nil num:nil

Take a minute to contemplate how great it is to be one of Mother Nature's
top-of-the-line products: a human. As a human, you get to gossip on social
media, play Dungeons and Dragons, and wear hats. Perhaps more important, you get
to think and communicate in terms of abstraction.

The ability to think in terms of abstraction is truly one of the best human
features. It lets you circumvent your cognitive limits by tying together
disparate details into a neat conceptual package that you can hold in your
working memory. Instead of having to think clunky thought "squeezable honking
red ball nose adornment," you only need the concept "clown nose."

In Clojure, an /abstraction/ is collection of operations, and /data types/
implement abstractions. For example, the /seq/ abstraction consists of
operations like /first/ and /rest/, and the vector data types is an
implementation of that abstraction; it responds to all of the /seq/ operations.
A specific vector like /[:seltzer :water]/ is an /instance/ of tat data type.

the more a programming language lets you think and write in terms of
abstraction, the more productive you will be. For example, if you learn that a
data structure is an instance of the /seq/ abstraction, you can instantly call
forth a large web of knowledge about what function will work with the data
structure. As a result, you spend time actually using the data structure instead
of constantly looking up documentation on how it works. By the same token, if
you extend a data structure to work with the /seq/ abstraction, you can use the
extensive library of /seq/ functions on it.

In Chapter 4, you learned that Clojure is written in terms of abstractions. This
is powerful because in Clojure you can focus on what you can actually do with
data structures and not worry about the nitty-gritty of implementation. This
chapter introduces you to the world of creating and implementing your own
abstractions. You'll learn the basic of multimethods, protocols, and records.

* Polymorphism

The main way we achieve abstraction in Clojure is by associating an operation
name with more than one algorithm. This technique is called /plymorphism/. For
example, the algorithm for performing /conj/ on a list is different form the one
for vectors, but we unify them under the same name to indicate that they
implement the same concept, namely, /add an element to this data structure/.

Because Clojure relies on Java's standard library for many of its data types, a
little Java is used in this chapter. For example, Clojure strings are just Java
strings, instances of the Java class /java.lang.String/. To define your own data
types in Java, you use classes. Clojure provides additional type construct:
/records/ and /types/. This book only covers records.

Before we learn about records, thought, let's look at multimethods, our first
tool for defining polymorphic behavior.

** Multimethods

/Multimethods/ give you a direct, flexible way to introduce polymorphism into
your code. Using multimethods, you associate a name with multiple
implementations by defining a /dispatching function/, which produces
/dispatching values/ that are used to determine which /method/ to use. The
dispacthing function is like the host at restaurant. The host will ask you
question like "Do you have a reservation?" and "Party Size?" and then seat you
accordingly. Similarly, when you call a multimethod, the dispatching[fn:1]
function will interrogate the arguments and send them to the right method, as
this example shows:

#+begin_src clojure :results value verbatim :exports both eval: never-export
  (ns were-creatures)

  (defmulti full-moon-behavior (fn [were-creature] (:were-type were-creature)))  ;; [L-1]

  (defmethod full-moon-behavior :wolf  ;; [L-2]
    [were-creature]
    (str (:name were-creature) " will howl and murder"))

  (defmethod full-moon-behavior :simmons  ;; [L-3]
    [were-creature]
    (str (:name were-creature) " will encourage people and swat to the oldies"))

  (full-moon-behavior {:were-type :wolf
                       :name "Rachel from next door"})  ;; [L-4]
  ;; =>"Rachel from next door will howl and murder"

  (full-moon-behavior {:name "Andy the baker"
                       :were-type :simmons})  ;; [L-5]
  ;; =>"Andy the baker will encourage people and swat to the oldies"
#+end_src

This multimethod shows how you might define the full moon behavior of different
kinds of were-creatures. Everyone knows that a werewolf turns into a wolf and
runs around howling and murdering people. A lesser known species of
/were-creature/, the /were-Simmons/, turns into Richard Simmons, power perm and
all, and runs around encouraging people to be their best and sweat to the
oldies. You do not want to get bitten by either, lest you turn into one.

We create the multimethod at [L-1]. This tells Clojure, "Hey, create a new
multimethod named /full-moon-behavior/. Whenever someone calls
/full-moon-behavior/, run the dispatching[fn:1] function /(fn [were-creature]
(:were-type were-creature))/ on the arguments. Use the result of the function,
aka the dispatching value, to decide which specific method to use!"

Next, we define two methods, one for when the value returned by the dispacthing
function is /:wolf/ at [L-2], and one for when it's /:simmons/ at [L-3]. Method
definition look a lot like function definitions, but the major difference is
that the method name is immediately followed by the /dispatch value/. /:wolf/
and /:simmons/ are both /dispatch value/. this is different from a dispatching
value, which is what the dispatching function returns. The full dispatch
sequence goes like this:

1. The form /(full-moon-behavior {:were-type :wolf :name "Rachel from next
   door"})/ is evaluated.

2. /full-moon-behavior's/ dispatching functions runs, returning /:wolf/ as the
   dispatching value.

3. Clojure compares the dispatching value /:wolf/ to the dispatch values of
   all the methods defined for /full-moon-behavior/. The dispatch values are
   /:wolf/ and /:simmons/.

4. Because the dispatching value /:wolf/ is equal to the dispatch value
   /:wolf/ the algorithm for /:wolf/ runs.

Don't let the terminology trip you up! The main idea is that the dispatching
function returns some value, and this value is used to determine which method
definition to use.

Back to our example! Next we call the method twice. At [L-4], the dispatching
function returns the value /:wolf/ and the corresponding method is used,
informing you that /"Rachel form next door will howl and murder". At [L-5], the
function behaves similarly, except /:simmons/ is the dispatching value.

You can define a method with /nil/ as the dispatch value:

#+begin_src clojure :results value verbatim :exports both eval: never-export

  (defmethod full-moon-behavior nil
    [were-creature]
    (str (:name were-creature) " will stay at home and eat ice cream"))

  (full-moon-behavior {:were-type nil
                       :name "Martin the nurse"})

  ;; =>"Martin the nurse will stay at home and eat ice cream"
#+end_src

when you call /full-moon-behavior/ this time, the argument you give it has /nil/
for its /:were-type/, so the method corresponding to /nil/ gets evaluated and
you're informed that /"Martin the nurse will stay at home and eat ice cream"/.

You can also define a default method to use if no other methods match by
specifying /:default/ as the dispatch value. In this example, the /:were-type/
of the argument given doesn't match any of the previously defined methods, so
the default method is used:

#+begin_src clojure :results value verbatim :exports both eval: never-export
  (defmethod full-moon-behavior :default
    [were-creature]
    (str (:name were-creature) " will stay up all night fantasy footballing"))

  (full-moon-behavior {:were-type :office-worker
                       :name "Jimmy from sales"})
  ;; =>"Jimmy from sales will stay up all night fantasy footballing"
                       #+end_src

One cool thing about multimethods is that you can always add new methods. If you
publish a library that includes the /were-creatures/ namespace, other people can
continue extending the multimethod to handle new dispatch values. This example
shows that you're creating your own random namespace and including the
/were-creatures/ namespace, and then defining another method for the
/full-moon-behavior/ multimethod:

#+begin_src clojure :results value verbatim :exports both eval: never-export
  (ns random-namespace
    (:require [were-creatures]))
  (defmethod were-creatures/full-moon-behavior :bill-murray
    [were-creature]
    (str (:name were-creature) " will be the most likeable celebrity"))

  (were-creatures/full-moon-behavior {:name "Laura the intern"
                                      :were-type :bill-murray})
  ;; =>"Laura the intern will be the most likeable celebrity"
#+end_src

Your dispatching function can return arbitrary values using any or all of its
arguments. The next example defines a multimethod that takes two arguments and
returns a vector containing the type of each argument. It also defines an
implementation of that method, which will be called when each argument is a
string:

#+begin_src clojure :results value verbatim :exports both eval: never-export
  (ns user)
  (defmulti types (fn [x y] [(class x) (class y)]))
  (defmethod types [java.lang.String java.lang.String]
    [x y]
    "Two String!")

  (types "String 1 String 2")
#+end_src

Incidentally, this is why they're called /multimethods/: they allows
dispatch[fn:1] on multiple arguments. I haven't used this feature very often,
but I could see it being used in a role-playing game to write methods that are
dispatched according to, say, a mage's major school of magic and his magic
specialization. Either way, it's better to have it and not need it than need it
and not have it.

*** Note

Multimethods also allow hierarchical dispatching.Clojure lets you build custom
hierarchies, which I won't cover, but you can learn about them by reading the
documentation at https://clojure.org/reference/multimethods

** Protocols

Approximately 93.58 percent of the time, you'll want to dispatch to methods
according to an argument's type. For example, /count/ needs to use a differnet
method for vectors than it does for maps or for lists. Although it's possible to
perform type dispatch with multimethods, /protocols/ are optimized for type
dispatch They're more efficient than multimethods, and Clojure makes it easy for
you to succinctly specify protocol implementations.

A multimethod is just one polymorphic operation, whereas a protocol is a
/collection/ of one or more polymorphic operations. Protocol operations are
called methods, just like multimethod operations. Unlike multimethods, which
perform dispatch on arbitrary values returned by a dispatching function,
protocol methods are dispatched based on the type of the first argument, as
shown in this example:

#+begin_src clojure :results value verbatim :exports both eval: never-export
  (ns data-psychology)

  (defprotocol Psychodynamics  ;; [L-1 defprotocol] [L-2 Psychodynamics]
    "Plumb the inner depths of your data types."  ;; [L-3]
    (thoughts [x] "The data type's innermost thoughts")  ;; [L-4]
    (feelings-about [x] [x y] "Feelings about self or other"))  ;; [L-5]
#+end_src

First, there's /defprotocol/ at [L-1]. This take a name, /Psychodynamics/ [L-2],
and an optional docstring, /"Plumb the inner depths of your data types"/ [L-3].
Next are the method signatures. A /method signature/ consists of a name, an
argument specification, and optional docstring. The first method signature is
named /thoughts/ [L-4] and can take only one arguments. The second is named
/feelings-about/ [L-5] and can take one or two arguments. Protocols do have one
limitation: the methods can't have rest arguments. So a line like the following
isn't allowed:

#+begin_src clojure :results value verbatim :exports both eval: never-export
  (feelings-about [x] [x & others])
#+end_src

By defining a protocol, you're defining an abstraction, but you haven't yet
defining how that abstraction is implemented. It's like you're reserving names
for behavior (in this example, you're reserving /thoughts/ and /feelings/), but
you haven't defined what exactly the behavior should be. If you were to evaluate
/(thoughts "blorb")/, you would get an exception that reads, "No implementation
of method: thoughts of protocol data-psychology/Psychodynamics found for class:
java.lang.String." Protocols dispatch on the first argument's type, so when you
call /(thoughts "blorb")/, Clojure tries to look up the implementation of the
/thoughts/ methods for strings, and fails.

You can fix this sorry state of affairs by /extending/ the string data type to
/implement/ the /Psychodynamics/ protocols:

#+begin_src clojure :results value verbatim :exports both eval: never-export
  (extend-type java.lang.String  ;; [L-1]
    Psychodynamics  ;; [L-2]
    (thoughts [x] (str x " thinks, 'Truly, the character defines the data type'"))  ;; [L-3]
    (feelings-about  ;; [L-4]
      ([x] (str x " is longing for a simpler way of life"))
      ([x y] (str x " is envious of " y "'s simpler way of life"))))

  (thoughts "blorb")
  ;; =>"blorb thinks, 'Truly, the character defines the data type'" ;; [L-5]

  (feelings-about "schmorb")
  ;; =>"schmorb is longing for a simpler way of life"

  (feelings-about "schmorb" 2)
  ;; =>"schmorb is envious of 2's simpler way of life"
#+end_src

/extend-type/ is followed by the name of the class or type you want to extend
and the protocol you want it to support--in this case, you specify the class
/java.lang.String/ at [L-1] and the protocol you want it to support,
/Psychodynamics/, at [L-2]. After that, you provide an implementation for both
the /thoughts/ method at [L-3] and the /feelings-about/ method at [L-4]. If
you're extending a type to implement a protocol, you have to implement every
method in the protocol or Clojure will throw an exception. In this case, you
can't implement just /thoughts/ or just /feelings/; you have to implement both.

Notice that these method implementations, don't begin with /defmethod/ like
multimethods? To do that, you can extend /java.lang.object/. This works because
every type in Java (and hence, Clojure) is a descendant of /java.lang.Object/.
If that doesn't quite make sense (perhaps because you're not familiar with
object-oriented programming), don't worry about it--just know that it works.
Here's how you would use this technique to provide a default implementation for
the /Psychodynamics/ protocol:

#+begin_src clojure :results value verbatim :exports both eval: never-export
  (extend-type java.lang.Object
    Psychodynamics
    (thoughts [x] "Maybe the internet is just a vector to toxoplasmosis")
    (feelings-about
      ([x] "meh ")
      ([x y] (str "meh about " y))))

  (thoughts 3)
  ;; =>"Maybe the internet is just a vector to toxoplasmosis"

  (feelings-about 3)
  ;; =>"meh "

  (feelings-about 3 "blorb")
  ;; =>"meh about blorb"
#+end_src

Because we haven't defined a /Psychodynamics/ implementation for numbers, Clojure dispatche[fn:2]s calls to /thoughts/ and /feelings/ to the implementation defined for /java.lang.Object/.

Instead of making multiple calls to /extend-type/ to extend multiple types, you
can use /extend-protocol/, which lets you define protocol implementation for
multiple types at once. Here's how you'd define the preceding protocol
implementation:

#+begin_src clojure :results value verbatim :exports both eval: never-export

  (extend-protocol Psychodynamics
    java.lang.String
    (thoughts [x] (str x " thinks, 'Truly, the character defines the data type'"))
    (feelings-about
      ([x] (str x " is longing for a simpler way of life"))
      ([x y] (str x " is envious of " y "'s simpler way of life")))

    java.lang.Object
    (thoughts [x] "Maybe the internet is just a vector to toxoplasmosis")
    (feelings-about
      ([x] "meh ")
      ([x y] (str "meh about " y))))

  ;; ==============
  ;; If you have a problem in REPL,
  ;; You can try with the full data-psychology namespace written down below:
  ;; ==============
  (ns data-psychology)

  (defprotocol Psychodynamics
    "Plumb the inner depths of your data types."
    (thoughts [x] "The data type's innermost thoughts")
    (feelings-about [x] [x y] "Feelings about self or other"))

  (extend-type java.lang.String
    Psychodynamics
    (thoughts [x] (str x " thinks, 'Truly, the character defines the data type'"))
    (feelings-about
      ([x] (str x " is longing for a simpler way of life"))
      ([x y] (str x " is envious of " y "'s simpler way of life"))))

  (extend-type java.lang.Object
    Psychodynamics
    (thoughts [x] "Maybe the internet is just a vector to toxoplasmosis")
    (feelings-about
      ([x] "meh ")
      ([x y] (str "meh about " y))))

  (extend-protocol Psychodynamics
    java.lang.String
    (thoughts [x] (str x " thinks, 'Truly, the character defines the data type'"))
    (feelings-about
      ([x] (str x " is longing for a simpler way of life"))
      ([x y] (str x " is envious of " y "'s simpler way of life")))

    java.lang.Object
    (thoughts [x] "Maybe the internet is just a vector to toxoplasmosis")
    (feelings-about
      ([x] "meh ")
      ([x y] (str "meh about " y))))
#+end_src

You might find this technique more convenient than using /extend-type/. Then
again, you might not. How does /extend-type/ make you feel? How about
/extend-protocol/? Come sit down on this couch and tell me about it.

It's important to note that a protocol's methods "belong" to the namespace that
they're defined in. In these examples, the fully qualified names of the
/Psychodynamics/ methods are /data-psychology/feelings-about/. If you have an
object-oriented background, this might be weird because methods belong to data
types in OOP. But don't freak out! It's just another way that Clojure gives
primary to abstractions. One consequence of this fact is that, if you want two
different protocols to include methods with the same name, you'll need to put
the protocols in different namespace.


Why this is necessary, with two different protocols to include methods with the
same name is broken the code:

In OOP:

- Method belong to class
- Each class can have the same method name:

  #+begin_src java :results value verbatim :exports both eval: never-export
    Dog.makeSound();
    cat.makeSound();
    Person.makeSound();
  #+end_src

It's no problem.

But in Clojure:

- A protocol's methods belong to /namespace/, not the type.
- So if you put two protocols in the same namespace with a method having the
  same name, they clash.

Clojure says:

"Method names in the same namespace must be unique"

Because protocol methods live in namespace:

you can define:

#+begin_src clojure :results value verbatim :exports both eval: never-export
  ns1/do-it
  ns2/do-it
#+end_src

But you cannot define:

#+begin_src clojure :results value verbatim :exports both eval: never-export
  ns1/do-it ;; (in protocol A)
  ns1/do-it ;; (in protocol B)
#+end_src

Thus protocol using the same method name must be placed in different namespaces.

* Records

Clojure allows you to create /records/, which are custom, maplike data types.
They're maplike in that they associate with values, youcan look up their value
the same way you can with maps, and they're immutable like maps. They're
different in that you specify /fields/ for records. Fields are slots for stat;
using them is like specifying which keys a data structure should have. Records
also different from maps in that you can extend them to impelement protocols.

To create a record, you use /defrecord/ to specify its name and fields:

#+begin_src clojure :results value verbatim :exports both eval: never-export
  (ns were-records)
  (defrecord WereWolf [name title])
  ;; => were_records.WereWolf
#+end_src

This record's name is /WereWolf/, and its two fields are /name/ and /title/. You
can create an instance of this record in three ways:

#+begin_src clojure :results value verbatim :exports both eval: never-export
  (WereWolf. "David" "London Tourist")  ;; [L-1]
  ;; =>{:name "David", :title "London Tourist"}

  (->WereWolf "Jacob" "Lead shirt Discarder")  ;; [L-2]
  ;; =>{:name "Jacob", :title "Lead shirt Discarder"}

  (map->WereWolf {:name "Lucian" :title "CEO of Melodrama"})  ;; [L-3]
  ;; =>{:name "Lucian", :title "CEO of Melodrama"}
#+end_src

At [L-1], we create an instance the same way we'd create a Java object, using
the class instantiation interop call. /(Interop/ refers to the ability to
interact with native Java construct within Clojure.) Notice that the arguments
must follow the same order as the field definition. This work because records
are actually Java classes under the covers.

The instance at [L-2] looks nearly identical to the one at [L-1], but the key
difference is that /->WereWolf/ is a function. When you create a record, the
factory functions /->RecordName/ and /map->RecordName/ are created
automatically. At [L-3], /map->WereWolf/ takes a map as an argument with
keywords that correspond to the record type's fields and returns a record.

If you want to use a record type in another namespace, you'll have to import it,
just like you did with Java classes in Chapter 12. Be careful to replace all
dashes in the namespace with underscores. This brief example shows how you'd
import the /WereWolf/ record type in another namespace:

#+begin_src clojure :results value verbatim :exports both eval: never-export
  (ns monster-mash
    (:import [were_records WereWolf]))

  (WereWolf. "David" "London Touris")
  ;; => #were_records.werewolf {:name "David", :title "London Touris"}

  (type (WereWolf. "David" "London Tourist"))
  ;; => were_records.WereWolf

  (instance? were_records.WereWolf (WereWolf. "David" "London Tourist"))
  ;; => true
  #+end_src

Notice that /were_records/ has an underscore, not a dash.

You can look up records values in the same way you look up map values, and you
can also use java field access interop:

#+begin_src clojure :results value verbatim :exports both eval: never-export
  ;; IMPORTANT:
  ;; what the book said is just use ':require'. But it must use ':refer to bring'
  ;; '->WereWolf' and 'map->WereWolf into namespace.

  (ns monster-mash
    (:require [were-records :refer [->WereWolf map->WereWolf]])
    (:import [were_records WereWolf]))

  (def jacob (->WereWolf "Jacob" "Lead Shirt Discarder"))
  ;; => #'monster-mash/jacob
  (.name jacob)  ;; [L-1]
  ;; =>"Jacob"
  (:name jacob)  ;; [L-2]
  ;; =>"Jacob"
  (get jacob :name)  ;; [L-3]
  ;; =>"Jacob"

  ;; Or if you don't want to refer them, you can still call function by full name:
  (def jacob (were-records/->WereWolf "Jacob" "Lead Shirt Discarder"))
  ;; => #'monster-mash/jacob
  monster-mash> (.name jacob)
  ;; => "Jacob"
  monster-mash> (:name jacob)
  ;; => "Jacob"
  monster-mash> (get jacob :name)
  ;; => "Jacob"

#+end_src

The first example, /(.name jacob)/ at [L-1], uses Java interop, and the examples
at [L-2] and [L-3] access /:name/ the same way you would with a map.

when testing for equality, clojure will check the all fields are equal and that
the two comparands have the same type:

#+begin_src clojure :results value verbatim :exports both eval: never-export
  (= jacob (->WereWolf "Jacob" "Lead Shirt Discarder"))
  ;; => true
  ;;  this result is because you define Jacob that created in 'were-record
  ;;  namespace
  (= jacob (WereWolf. "david" "london tourist"))
  ;; => false
  (= jacob {:name "Jacob" :title "Lead Shirt Discarder"})
  ;; => false
#+end_src

The test at [L-1] returns /true/ because /jacob/ and the newly created record
are of the same type and their fields are equal. The test at [L-2] returns
/false/ because the fields aren't equal. The final test at [L-3] returns /false/
because the two comparands don't have the same type: /jacob is a WereWolf/
record, and the other argument is a map.

Any function you can use on a map, you can also on a record:

#+begin_src clojure :results value verbatim :exports both eval: never-export
  (assoc jacob :title "Lead Third Wheel")
  ;; => #were_records.werewolf {:name "Jacob", :title "Lead Third Wheel"}

  monster-mash> (assoc jacob :title "Lead Third Wheel")
  ;; => {:name "Jacob", :title "Lead Third Wheel"}
#+end_src

However, if you /dissoc/ a field, the result's type will be a plain of Clojure
map; it won't have the same data type as the original record:

#+begin_src clojure :results value verbatim :exports both eval: never-export
  (dissoc jacob :title)
  ;; =>{:name "Jacob"} <- that's not a were_records.WereWolf
#+end_src

This matters for at least two reasons: first, accessing map values is slower
than accessing record values, so watch out if you're building a high-performance
program. Second, when you create a new record type, you can extend it to
implement a protocol, similar to how you extended a type using /extend-type/
earlier. If you /dissoc/ a record and then try to call a protocol method on the
result, the record's protocol methods won't be called.

Here's how you could extend protocol when defining a record:

#+begin_src clojure :results value verbatim :exports both eval: never-export
  (ns were-records)
  (defprotocol WereCreature  ;; [L-1]
    (full-moon-behavior [x]))  ;; [L-2]

  (defrecord WereWolf [name title]  ;; [L-3]
    WereCreature
    (full-moon-behavior [x]
      (str name " will howl and murder")))

  (full-moon-behavior (map->WereWolf {:name "Lucian" :title "CEO of Melodrama"}))
  ;; => "Lucian will howl and murder"
#+end_src

We've created a new protocol, /WereCreature/ [L-1], with one method,
/full-moon-behavior/ [L-2]. At [L-3], /defrecord/ implements /WereCreature/ of
/WereWolf/. The most interesting part of the /full-moon-behavior/ implementation
is that you have access to /name/. You also have access to /title/ and any other
fields that might be defined for your record. you can also extend records using
/extend-type/ and /extend-protocol.

When should you use records, and when should you use maps? In general, you
should consider using record if you find yourself creating maps with the same
fields over and over. This tells you that set of data represents information in
you application's domain, and your code will communicate its purpose better if
you provide a name based on the concept you're trying model. Not only that, but
record access is more performant than map access, so your program will become a
bit more efficient. Finally, if you want to use protocol, you'll need to create
a record.

* Further Study

Clojure offers others tools for working with abstraction and data types. These
tools, which I consider advanced, include /deftype/, /reify/, and /proxy/. If
you're interested in learning more, check out documentation on data types at https://clojure.org/reference/datatypes.



* Summary

One of Clojure's design principles is to write to abstractions, in this chapter,
you learned how to define your own abstractions using multimethods and
prototypes. These constructs provide polymorphism, allowing the same operation
to behave differently based on the arguments it's given. You also learned how to
create and use your own associative data types with /defrecord/ and how to
extend records in implement protocols.

When I firs started learning Clojure, I was pretty shy about using multimethods,
protocols, and records. However, they are used often in Clojure libraries, so
it's good to know how they work. Once you get the hang of them, they'll help you
write cleaner code.


* Exercises

1. Extend the /full-moon-behavior/ multimethod to add behavior for your own kind
   of /were-creature/.

2. Create a /WereSimmons/ record type, and then extend the /WereCreature/
   protocol.

3. Create your own protocol, and then extend it using /extend-type/ and
   /extend-protocol/.

4. Create a role-playing game that impelements behavior using multiple dispatch.



* Extra

- What is polymorphism in Clojure? what it's make different with others
  programming language that implement polymorphism?

  - In Clojure, polymorphism is:

  The ability to provide different methods implementations that are selected at
  runtime based on dispatch algorithm, not limited to static type heirarchies.

  Clojure support polymorphism through:

  1. Protocols (like interfaces in java, but extendable independently)
     - Fast
     - Like OOP interfaces
     - Dispatch on Type

  2. Multimethods (Clojure Superpower)
     - Dispatch on anything: type, value, count, metadata, logic, etc.
     - More powerful that Java/Python/C++
     - Encourage open extensibility

  3. Records
     - Concrete types at impelement protocol
     - Polymorphism through protocol


 - Polymorphism = the function you call depends on the type of the input.

   example in Clojure:

   #+begin_src clojure :results value verbatim :exports both eval: never-export
     (defmulti greet class)

     (defmethod greet String [name]
       (str "Hello " name))

     (defmethod greet Number [n]
       (str "Number says hi: " n))
   #+end_src

  Now calling /greet/:

   #+begin_src clojure :results value verbatim :exports both eval: never-export
     (greet "jacob")
     ;; => "Hello jacob"
     (greet 42)
     ;; => "Number says hi: 42"
   #+end_src

 Same function name -> different behavior depending on input type.


 Clojure polymorphism differs from other:

 - How dispatch works:
   - Java/Python/C++: usually dispatch on type only
   - Clojure: Can dispatch on anything (value, type, attributes, logic)

 - Where methods live:
   - Java/Python/C++: Inside class
   - Clojure: in namespaces (data stays separate)

 - Extending types:
   - Java/Python/C++: Must change the class
   - Clojure: Can extend types after they exist, even built-ins

- Multimethods:
   - Java/Python/C++: Not available
   - Clojure: Fully dynamic, rule-based

- Protocols:
   - Java/Python/C++: Like interfaces
   - Clojure: But extendable for types anywhere, anytime

- Open extension:
   - Java/Python/C++: Usually closed
   - Clojure: Open: add methods without modifying original code

Example: Clojure polymorphism that Java cannot do

Java dispatches only type.

clojure can dispatch ANY rule you decide:

#+begin_src clojure :results value verbatim :exports both eval: never-export
  (defmulti speedn (fn [animal] (count (:legs animal))))

  (defmethod speed 2 [_] :slow)
  (defmethod speed 4 [_] :medium)
  (defmethod speed 8 [_] :fast)
#+end_src

now:

#+begin_src clojure :results value verbatim :exports both eval: never-export
  (speed {:legs [:leg1 :leg2]})  ;; :slow
  (speed {:legs [:l1 :l2 :l3 :l4]})  ;; :medium
  (speed {:legs (range 8)})  ;; :fast
#+end_src





* Footnotes
[fn:1] Running a function that decided which version of multimethod to call. In
programming context dispatch can be translated as "assignment" or "sending".
This the way in which a program "assign" or "dispatches" the appropriate
function to be executed.

The concept of dispatch was introduced into programming context in 1960s,
particularly with the development of Object Oriented programmin languages. One
system that implemented this idea is Smalltalk, designed in the early 1970s by
Alan Kay, Dan Ingalls and teams. They develop the idea of objects and messages,
where object would "get" the appropriate method or function based on the
Object's and the context of the interaction.

[fn:2] redirect or forward calls to the appropriate method or function.
