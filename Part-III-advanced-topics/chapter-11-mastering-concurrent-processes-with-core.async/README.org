#+TITLE: Clojure For The Brave and True Part III --   Chapter 11: Mastering Concurrent Processes with core.async
#+DATE: 2025-11-08 Sat
#+AUTHOR: Agung Tuanany
#+DESCRIPTION: Clojure, book, A summary per chapter from book clojure-for-the-brave-and-true.
#+KEYWORDS: programming, clojure, clojure-for-the-brave-and-true.
#+OPTIONS: toc:nil num:nil

One day, while you are walking down the street, you will be surprised,
intrigued, and a little disgusted to discover a hot dog vending machine. Your
scalp tingling with guilty curiosity, you won't be able to help yourself form
pulling out three dollars and seeing if this contraption actually works. After
accepting your money with a click and a whir, it pops out a fresh hot dong, bun
and all.

The vending machine exhibits simple behavior, when it receives money, it
releases a hot dog and then gets ready for the next purchase. When it's out of
hot dog and then gets ready for the next purchase. When it's out of hot dogs, it
stops. All around us are hot dong vending machines in different
guises--independent entities concurrently responding to events in the world. The
espresso machine at your favorite coffee shop, the pet hamster you loved as a
child--everything can be deconstructed into a set of behaviors that follows the
general form "when /x/ happens, do /y/." Even the program we write are just
glorified hot dog vending machines, each one an independent process waiting for
the next even. whether it's a keystroke, a timeout, or the arrival of data on a
socket.

Clojure's core.async library allows you to create multiple independent processes
within a single program. This chapter describes a useful model for thinking
about this style of programming as well as the practical details you need to
know to actually write code. You'll learn how to use channels to communicate
between independent processes created by go blocks and /thread/; a bit about how
Clojure manages threads efficiently with parking and blocking; how to use
/alts!!/; and a more straightforward way of creating queues. Finally, you'll
learn how to kick callbacks in the butt with process pipeline.

* Getting Started with Processes

At the first of core.async is the /process/, a concurrently running unit of
logic that responds to events. The process corresponds to our mental model of
the real world: entities interact with and respond to each other independently
without some kind of central control mechanism pulling the strings. You put your
money in the machine, and out comes a hotdog, all without the illuminati or Big
Brother orchestrating the whole thing. This differs from the view of concurrency
you've been exploring so far, where you've defined tasks that are either mere
extensions of the main thread of control (for example, achieving data
parallelism with /pmap/) or tasks that you have no interest in communicating
with (like one-off tasks created with /future/).

It might be strange to think of a vending machine as a process: vending machine
are noun-/y/ and thing-/y/, and process are verb-/y/ and do-/y/. To get in the
right mindset, try defining real-word objects as the sum of their event-driven
behavior. When a seed gets watered, it sprouts; when a mother looks at her
newborn child, she feels love; and when you watch /Star Wars Episode 1/, you are
filled with anger and despair. If you want to get super philosophical, consider
whether it's possible to define every thing's essence as the set of the events
it recognizes and how it responds. Is reality just the composition of hot dog
vending machine?

Anyway, enough of my yanking! Let's move from the theoretical to the concrete by
creating some simple processes. First, create a new Leiningen project called
/playsync/ with /lein new app playsync/. Then, open the fiel /project.clj/ and
add core.async to the /:dependencies/ vector so it reads as follows:

#+begin_src clojure :results value verbatim :exports both eval: never-export
  [org.clojure/clojure "1.7.0"]
  [org.clojure/core.async "0.1.346.0-17112a-alpha"]
#+end_src

#+begin_comment
*NOTE*

It's possible that the core.async version has advanced since I wrote this. For
the latest version, check the core.sync Github project page. But for the purpose
of these exercises, please use the version listed here
#+end_comment

Next, open src/playsync/core.clj and make it look like this:

#+begin_src clojure :results value verbatim :exports both eval: never-export
  (ns playsync.core
    (:require [clojure.core.async
               :as a
               :refer [>! <! >!! <!! go chan buffer close! thread alts! alts!!
                       timeout]]))
#+end_src

Now when you open this in a REPL, you'll have the most frequently used
core.async function at your disposal. Great! Before creating something as
sophisticated and revolutionary as a hot dog vending machine, create a process
that simply prints the messag it receives:

#+begin_src clojure :results value verbatim :exports both eval: never-export
  (def echo-chan (chan))
  (go (println (<! echo-chan)))
  (>!! echo-chan "ketchup")
#+end_src

At the first line of code, you used to /chan/ function to create a /channel/
named /echo-chan/. Channels communicate /messages/. You can /put/ messages on a
channel and /take/ messages off a channel. Process /wait/ for the completion of
put and take--these are the events that processes respond to. You can think of
processes as having two rules: [1] when trying to put a message on a channel or
take a message off of it, wait and do nothing until the put or take succeeds,
and [2] when the put or take succeeds, continue executing.

On the next line, you use /go/ to create a new process. Everything within the
/go/ expression--called a /go block/--runs concurrently on a separate thread. Go
blocks run your process on a thread pool that contains a number of threads equal
to two plus the number of cores on your machine, which means your program
doesn't have to create a new thread for each process. This often result in
better performance because you avoid the overhead associated with creating
threads.

In the expression /(<! echo-chan)/, /<!/ is the /take/ function. It listens to
the channel you give it as an argument, and the process it belongs to waits
until another process puts a message on the channel. When /<!/ retrieves a
value, the value is returned and the println expression is executed.

The expression /(>!! echo-chan "ketchup")/ /puts/ the string /"ketchup"/ on
/echo-chan/ and return /true/. When you put a message on a channel, the process
blocks until another process takes the message. In this case, the REPL process
didn't have to wait at all, because there was already a process listening to the
channel, waiting to take something off it. However, if you do the following,
your REPL will block indefinitely:

#+begin_src clojure :results value verbatim :exports both eval: never-export
  (>!! (chan) "mustard")
#+end_src

You've created a new channel and put something on it, but there's no process
listening to that channel. Process don't just wait to receive messages; they
also wait for the message they put on a channel to be taken.

*** Simple code going on:

1. /(chan)/ creates a new unbuffered channel -- that means any send (/>!/ or
   />!!/) will block until something is ready to take (/<!/ or /<!!/) form the
   channel.

   So here, /echo-chan/ can hold only one message at a time and only if someone
   is ready to take it.

2. /(go ...)/ start a lightweight thread (a "process" managed by Clojure's
   runtime).

   Inside, you're doing /<! echo-chan/, which means "wait until a value comes
   from this channel."

   So this process parks -- it's not spinning the CPU -- it just quietly waits.

3. Then, /(>!! echo-chan "ketchup")/ sends the string /"ketchup"/ into the
   channel, blocking until someone receives it.

   That means this line won't finish until the /go/ block inside can take the
   value.

When both are ready--the sender /(>!!)/ and the receiver /(<!)/--Clojure
transfers the value /"ketchup"/ through the channel, unblocking both sides.

Quick recap of what is saw:

  - Buffering: None here--the channel is unbuffered, so both sender and receiver
    must meet

  - Blocking: Happens in the main thread at />!!/ (waiting for the receiver).

  - ParkingL Happens in the /go/ block at /<!/ (waiting for a value).

** Buffering

It's worth nothing that the previous exercise contained /two/ processes; the one
you created with /go/ and the REPL process. These processes don't have explicit
knowledge of each other, and they act independently.

Let's imagine that these processes take place in a diner. The REPL is the
ketchup chef, and when he's done with a batch, he belts out "Ketchup!" it's
entirely possible that the rest of the staff is outside admiring the latest
until someone shows up to take his ketchup. On the flip side, the /go/ process
represents one of the staff, and he'swaiting patiently for something to respond
to. It could be that nothing ever happens, and he just waits indefinitely until
the restaurant closes.

This situation seems a little silly: what self-respecting ketchup chef would
just sit and wait for someone to take his latest batch before making more
ketchup? To avoid this tragedy, you can create buffered channels:

#+begin_src clojure :results value verbatim :exports both eval: never-export
  (def echo-buffer (chan 2))
  (>!! echo-buffer "ketchup")
  ;; => true
  (>!! echo-buffer "ketchup")
  ;; => true
  (>!! echo-buffer "ketchup")
  ;; this blocks because the channel is full
#+end_src

(Be careful the last /(>!! echo-buffer "ketchup")/ because it will block your
REPL. If you're using a Leiningen REPL, /CTRL-C/ will unblock it)

In this case, you've created a channel with buffer size 2. Than means you can
put two values on the channels without waiting, but putting a third one on means
the process will wait until another process takes a value from the channel. You
can also create /sliding/ buffers with /sliding-buffer/.

Which drops values in first-in, first-out fashion; and /dropping/ buffers with
/dropping- buffer/, which discards value in a last-in, first-out fashion.
Neither of these buffers will ever cause />!!/ to block.

By using buffers, the master ketchup chef can keep whipping up batches of
mouthwatering ketchup without having to wait for his staff to take them away. If
he's using a regular buffer, it's like he has a shelf to put all his ketchup
batches on; once the shelf is full, he'll still have to wait for space to open
up. If he's using a sliding buffer, he'd throw away the oldest batch of ketchup
when the shelf is full, slide all he ketchup down, and put the new batch in the
vacant space. With a dropping buffer, he'd just knock the freshet batch off the
shelf and put his new batch in that space.

Buffers are just elaborations of the ore model: processes are independent,
concurrently executing units of logic that respond to events. You can create
processes with go block and communicate events over channels.

** Blocking and Parking

You may have notice that the take function /<!/ used only one exclamation point,
whereas the put function />!!/ used two. In fact, both put and take have
one-exclamation-point and two-exclamation-point varieties. When do you use
which? The simple answer is that you can use one exclamation point inside go
blocks, but you have to use two exclamation points outside of them:


|      | inside go block | outside go block |
| put  | >! or >!!       | >!!              |
| take | <! or <!!       | <!!              |


It all comes down to efficiency. Because go blocks use a thread pool with a
fixed size, you can create 1.000 go processes but use only a handful of threads:

#+begin_src clojure :results value verbatim :exports both eval: never-export
  (def hi-chan(chan))
  (doseq [n (range)]
    (go (>! hi-chan (str "hi " n)))
#+end_src

To understand how Clojure accomplishes this, we need to explore how processes
/wait/. Waiting is a key aspect of working with /core.async/ processes: we've
already established that /put/ waits until another process does a /take/ on the
same channel, and vice versa. In this example, 1.000 processes are waiting for
another process to take form /hi-chan/.

There are two varieties of waiting: /parking/ and /blocking/. Blocking is the
kind of waiting you're familiar with: a thread stops executing until a task
operation. The thread remains alive but doesn't do any work, so you have to
create a new thread if you want your program to continue working. In Chapter 9,
you learned how to do this with /future/.

Parking frees up the threads so it can keep doing work. Let's say you have one
thread and two processes, Process A and Process B. Process A is running on the
thread and then waits for a put or take. Clojure moves Process A off the thread
and moves Process B onto the thread. If Process B starts waiting and Process A's
put or take has finished, then Clojure will move Process B off the thread and
put Process A back on it. Parking allows the instructions from using multiple
threads allows interleaving on a single core. The implementation of parking
isn't important; suffice it to say that it's only possible within go blocks, and
it's only possible when you use />!/ and /<!/, or /parking put/ and /parking
take/. />!!/ are /blockin put/ and /blocking take/.

** thread

There are definitely times when you'll want to use blocking instead of parking,
like when your process will take a long time before putting or taking, and for
those occasions you should use /thread/:

#+begin_src clojure :results value verbatim :exports both eval: never-export
  (thread (println (<!! echo-chan)))
  (>!! echo-chan "mustard")
  ;; => true
  ;; => mustard
#+end_src

/thread/ acts almost exactly like /future/: it create a new thread and executes
a process on that thread. Unlike /future/,instead of returning an object that
you can dereference, /thread/ returns a channel. When /thread's/ process stops,
the process's return value is put on the channel that /thread/ returns:

#+begin_src clojure :results value verbatim :exports both eval: never-export
  (let [t (thread "chili")]
    (<!! t))
  ;; "chili"
#+end_src

In this case, the process doesn't wait for any events; instead, it stops
immediately. It's return value is /"chili", which gets put on the channel that's
bound to /t/. We take from /t/, returning /"chili"/.

The reason you should use /thread/ instead of a go block when you're performing
a long-running task is so you don't clog your thread pool. Imagine you're
running four processes that download humongous files, save them, and then put
the file path on a channel. While the processes are downloading files and saving
these files, Clojure can't park their threads. It can park the thread only at
the last step, when the process puts the files' paths on a channel. Therefore,
if your thread pool has no other process will be allowed to run until one of the
download finished.

/go/, /thread/, /chan/, /<!/, /<!!/, />!/, />!!/ are the core tools you'll use
for creating and communicating with process. Both put and take will cause a
process to wait until its complement is performed on the given channel. /go/
allows you to use the parking variants of put and take, which could improve
performance. You should use the blocking variants, along with /thread/, if
you're performing long-running tasks before the put or take.

And hat should give you everything you need to fulfill your heart's desire and
create a machine that turns money into hot dogs.


** Summary (how to think about them together)

| Concept   | Function                 | Behavior                                 | Analogy                                     |
| Buffering | /(chan n)/               | Holds a messages before blocking         | "How many packages fit in mailbox"          |
| Blocking  | /<!!/,/>!!/              | Thread stops and waits                   | You wait at the counter until you're server |
| Parking   | /<!/, />!/ (inside /go/) | Go blocks pauses itself (no real thread) | You take a number and get called later      |

* The Hot Dog Machine Process Youâ€™ve Been Longing For

Beholds, you dream made real!

#+begin_src clojure :results value verbatim :exports both eval: never-export
  (defn hot-dog-machine
    []
    (let [in (chan)
          out (chan)]
      (go (<! in)
          (>! out "hot dog"))
      [in out]))
#+end_src

This function creates an /in/ channel for receiving money and an /out/ channel
for dispensing a hot dog. It then creates an asynchronous process with /go/.
Which wait for money and dispenses a hot dog. Finally, it returns the /in/ and
/out/ channels as a vector.

Time for a hot dog!

#+begin_src clojure :results value verbatim :exports both eval: never-export
  (let [[in out] (hot-dog-machine)]
    (>!! in "pocket list")
    (<!! out))
  ;; => "hot dog"
#+end_src


In this snippet, you use destructuring (covered in Chapter 3) with /let/ to bind
the /in/ and /out/ channels to the /in/ and /out/ symbols. You then put /"pocket
lint"/ on the /in/ channel. The hot dog machine process waits for something,
anything, to arrive on the /in/ channel; once /"pocket lint"/ arrives, the hot
dog machine process resume execution, putting /"hot dog"/ on the /out/ channel.

Wait a minute ... that's not right. I mean, yay, free hot dogs, but someone's
bound to get upset that the machine's accepting pocket lit as payment. Not only
that, but this machine will only dispense one hot dog before shutting down.
Let's alter the hot dog machine function so that you can specify how many hot
dogs it has and so it only dispense a hot dog when you give it the number 3:

#+begin_src clojure :results value verbatim :exports both eval: never-export
  (defn hot-dog-machine-v2
  [hot-dog-count]
  (let [in (chan)
        out (chan)]
    (go (loop [hc hot-dog-count]
          (if (> hc 0)
            (let [input (<! in)]
              (if (= 3 input)  ;; [L-1]
                (do (>! out "hot dog")
                    (recur (dec hc)))
                (do (>! out "wilted lettuce")  ;; [L-2]
                    (recur hc))))
            (do (close! in)
                (close! out)))))
    [in out]))
#+end_src

There's a lot more code here, but the strategy is straightforward. the new
function /hot-dog-machine-v2/ allows you to specify the /hot-dog-count/. Within
the go block [L-1], it dispenses a hot dog only if the number 3 (meaning three
dollars) is placed on the /in/ channel; otherwise, it dispenses wilted lettuce,
which is definitely not a hot dog. Once a process has taken the output, the hot
dog machine process loops back with an updated hot dog count and is ready to
receive money again.

When the machine process runs out of hot dogs, the process /closes/ the channel
at [L-2]. When you close a channel, you can no longer perform puts on it, and
once you've taken all values off a closed channel, any subsequent take will
return /nil/.

Let's give the upgraded hot dog machine a /go/ in Listing 11-1 by putting in
money and pocket lint:


#+caption: Listing 11-1: Interacting with a robust hot dog vending machine
#+attr_latex: scale=0.75
#+label: fig:listing

#+begin_src clojure :results value verbatim :exports both eval: never-export
  (let [[in out] (hot-dog-machine-v2 2)]
    (>!! in "pocket lint")
    (println (<!! out))
    (>!! in 3)
    (println (<!! out))

    (>!! in 3)
    (println (<!! out))

    (>!! in 3)
    (<!! out))

  ;; => wilted lettuce
  ;; => hot dog
  ;; => hot dog

  ;; ;; => nil
#+end_src

First, we try the ol' pocket lint trick and get wilted lettuce. Next, we put in
3 dollars twice and get a hot dog both times. Then, we try to put in another 3
dollars, but that ignored because the channel is closed; the number 3 is not put
on the channel. When we try to take from the /out/ channel, we get /nil/, again
because the channel is closed. You might notice a couple of interesting details
about /hot-dog-machine-v2/. First, it does a put and a take within the same go
block. This isn't that unusual, and it's one way yo can create a /pipeline/ of
processes; just make the /in/ channel of one process the /out/ channel of
another. The following example does just that, passing a string through a series
of processes that perform transformation until the string finally gets printed
by the last process:

#+begin_src clojure :results value verbatim :exports both eval: never-export
  (let [c1 (chan)
        c2 (chan)
        c3 (chan)]
    (go (>! c2 (clojure.string/upper-case (<! c1))))
    (go (>! c3 (clojure.string/reverse (<! c2))))
    (go (println (<! c3)))
    (>!! c1 "redrum"))
  ;; => MURDER
#+end_src

I'll have more to say about process pipelines and how you can use them instead
of callbacks toward the end of the chapter.

Back to Listing 11-1! Another thing to note is that the hot dog machine doesn't
accept more money until you've dealt with whatever it's dispensed. This allows
you to model state-machine-like behavior, where the completion of channel
operations triggers state transitions. For example, you can think of the vending
machine as having two state: /ready to receive money/ and /dispensed item/.
Inserting money and taking the item trigger transition between the two.

* alts!!

The core.async function /alts!!/ lets you use the result of the first successful
channel operation among a collection of operations. We did something similar to
this delays and futures in "Delays" on page 198. In that example, we uploaded a
set of headshots to headshot-sharing site and notified the headshot owner when
the first photo was uploaded. Here's how you'd o the same with /alts!!/:

#+begin_src clojure :results value verbatim :exports both eval: never-export
  (defn upload
    [headshot c]
    (go (Thread/sleep (rand 100))
        (>! c headshot)))

  (let [c1 (chan)  ;; [L-1]
        c2 (chan)
        c3 (chan)]
    (upload "serious.jpg" c1)
    (upload "fun.jpg" c2)
    (upload "sassy.jpg" c3)
    (let [[headshot channel] (alts!! [c1 c2 c3])] ;; [L-2]
      (println "Sending headshot notification for" headshot)))
#+end_src

Here, the /upload/ function takes a headshot and a channel, and creates a new
process that sleeps for a random amount of time (to simulate the upload) and
then puts the headshot on the channel. The /let/ bindings and /upload/ function
calls beginning at [L-1] should make sense; we create three channels and then
use them to perform the uploads.

Things get interested at [L-2], the /alts!!/ function takes a vector of channels
as its arguments. This is simultaneously. As soon as take succeeds, return a
vector whose first element is the value taken and whose second element is the
winning channel. "In this case, the channel associated with /sassy.jpg/ received
a value first. The other channels are still available if you want to take their
values and do something with them. All /alts!!/ does is take a value from the
first channel to have a value; it doesn't touch the other channels.

One cool aspect of /alts!!/ is that you can give it a /timeout channel/, which
waits the specified number of milliseconds and then closes. It's an elegant
mechanism for putting a time limit on concurrent operations. Here's how you
could use it with the upload service:

#+begin_src clojure :results value verbatim :exports both eval: never-export
  (let [c1 (chan)]
    (upload "serious.jpg" c1)
    (let [[headshot channel] (alts!! [c1 (timeout 20)])]
      (if headshot
        (println "Sending headshot notification for" headshot)
        (println "Timed out!"))))
#+end_src

In this case, we set the timeout to 20 milliseconds. Because the upload didn't
finish in that time frame, we got a timeout message.

You can also /alts!!/ to specify put operations. To do that, place vector inside
the vector you pass to /alts!!/, like [L-1] in this example:

#+begin_src clojure :results value verbatim :exports both eval: never-export
  (let [c1 (chan)
      c2 (chan)]
  (go (<! c2))
  (lt [[value channel] (alts!! [c1 [c2 "put!"]])]  ;; [L-1]
      (println value)
      (= channel c2)))
#+end_src


Here you're creating two channels and then creating a process that's waiting to
perform a take on /c2/. The vector that you supply to /alts!!/ tells it, "Try to
do a take on /c1/ and try to put "put!" on /c2/. If the take on /c1/ finishes
first, return its value and channel. If the put on /c2/ finishes first, return
/true/ if the put was successful and /false/ otherwise." Finally, the result of
/value/ (which is /true/, because the /c2/ channel was open) prints and shows
that the channel returned was indeed /c2/.

Like /<!!/ and />!!/, /alts!!/ has a parking alternative, /alts!/, which you can
use inside go blocks, /alts! is nice way to exercise some choice over which of a
group of channels you put or take from. It still performs puts and takes, so the
same reasons to use the parking or blocking variation apply.

And that covers the core.async basic! The rest of the chapter explains two
common patterns for coordinating

* Queues

In "Rolling Your Own Queue" on page 202, you wrote a macro that let you queue
futures. Processes let you use a similar technique in a more straightforward
manner Let's say you want to get a bunch of random quotes from a website and
write them to a single file. You want to make sure that only one quote is
written to a file at a time so the text doesn't get interleaved, so you put
quotes on a queue. Here's the full code:

#+begin_src clojure :results value verbatim :exports both eval: never-export
  (defn append-to-file
    "Write a string to the end of a file"
    [filename s]
    (split filename s :append true))

  (defn format-quote
    "Delineate the beginning and end of quote because it's convenient"
    [quote]
    (str "=== BEGIN QUOTE ====\n" quute "=== END QUOTE ===\n\n"))

  (defn random-quote
    "Retrieve a random quote and format it"
    []
    (format-quote (slurp "http://www.braveclojure.com/random-quote")))

  (defn snag-quotes
    [filename num-quotes]
    (let [c (chan)]
      (go (while true (append-to-file filename (<! c)))))
    (dotimes [n num-quotes] (go (>! c (random-quote)))))

#+end_src

The function /append-to-file/, /format-quote/, and /random-quote/ have
docstrings that explain what they do, /snag-quotes/ is where the interesting
work happens. First, it creates a channel that's shared between the
quote-producing processes and the quote-consuming process. Then it creates a
process that uses /while true/ to create an infinite loop. On every iteration of
the loop, it waits for a quote to arrive on /c/ and then appends it to a file.
Finally, /snag-quotes/ creates a /num-quotes/ number of processes that fetch a
quote and then put it on /c/. If you evaluate /(snag-quotes "quotes" 2)/ and
check the /quotes/ file in the directory where you started your REPL, it should
have two quotes:

#+begin_quote
=== BEGIN QUOTE ===
Nobody's gonna believe hat computers are intelligent until they start coming in
late and lying about it
=== END QUOTE ===

=== BEGIN QUOTE ===
Give your child mental blocks for Christmas
=== END QUOTE ===
#+end_quote

This kind of queuing differs from the example in Chapter 9. In that example,
each task was handled in the order it was created. Here, each quote-retrieving
task is handled in the order that it finishes. In both cases, you ensure that
only one quote a time is written to a file.

* Escape Callback Hell with Process Pipelines

In language without channels, you need to express the idea "When x happens, do
y" with /callbacks/. In a language like Javascript, callbacks are a way to
define code that executes asynchronously once other code finishes. If you've
worked with Javascript, you've probably spent some time wallowing in /callback
hell/.

The reason it's called callback hell is that it's very easy to create
dependencies among layers of callbacks that aren't immediately obvious. They end
up sharing state, making it difficult to reason about the state of the overall
system as the callbacks get triggered. You can avoid this depressing outcome by
creating a process pipeline. That way, each unit of logic occurs through
explicitly defined input and output channels.

In the following example, we create three infinitely looping processes connected
through channels, passing the /out/ channel of one process as the /in/ channel
of the next process in the pipeline:

#+begin_src clojure :results value verbatim :exports both eval: never-export
  (defn upper-caser
    [in]
    (let [out (chan)]
      (go (while true (>! out (clojure.string/upper-case (<! in)))))))

  (defn reverser
    [in]
    (let [out (chan)]
      (go (while true (>! out (clojure.string/reverse (<! in)))))))

  (defn printer
    [in]
    (go (while true (println (<! in)))))

  (def in-chan (chan))
  (def upper-case-out (upper-case in-chan))
  (def reverser-out (reverser upper-case-out))
  (printer reverser-out)
#+end_src

* Additional Resources

Clojure's core.async library was largely inspired by Go's concurrency model,
which is based on the work by Tony Hoare in Communicating Sequential Processes
and is available at http://www.usingcsp.com

Rob Pike, co-creator of Go, has a good talk on concurrency, which is available https://www.youtube.com/watch?v=f6kdp27TYZs.

ClojureScript, also known as the best thing to happen to the browser, use
core.async. No more callback hell! You can learn about ClojureScript at
https://github.com/clojure/clojurescript

Finally, check out the API docs at http://clojure.github.io/core.async

* Summary

In this chapter, you learned about how core.async allows you to create
concurrent processes that respond to the put and take communication events on
channels. You learned about how to use /go/ and /thread/ to create concurrent
processes that wait for communication events by parking and blocking. You also
learned how to create process pipelines by making the /out/ channel of one
process the /in/ channel of another, and how this allows you to write code
that's way more intelligible than nested callbacks. Finally, you meditated on
whether or not you're just a fancy hot dog vending machine.
